
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Specs &#8212; YeSQL specifications</title>
    <link rel="stylesheet" href="classic.css" type="text/css" />
    <link rel="stylesheet" href="pygments.css" type="text/css" />
    <script type="text/javascript">
      var specifications_OPTIONS = {
        URL_ROOT:    './',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="underscore.js"></script>
    <script type="text/javascript" src="doctools.js"></script>
    <script type="text/javascript" src="jsMath/easy/load.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Useful notes" href="usefulnotes.html" />
    <link rel="prev" title="About" href="about.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        
        <li class="nav-item nav-item-0"><a href="index.html">YeSQL specifications</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="manual">
<h1>Detailed Specifications<a class="headerlink" href="#manual" title="Permalink to this headline">¶</a></h1>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<p>Functions are the main mechanism with which extensions are implemented.
The are three kinds of functions:</p>
<ul class="simple">
<li>Scalar functions</li>
<li>Aggregate functions</li>
<li>Polymorphic tables</li>
</ul>
<p>YeSQL also provides syntactic extensions, in its supported SQL, that simplify the use of above functions.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="row.html#row-functions-list"><span class="std std-ref">Scalar functions list</span></a></li>
<li><a class="reference internal" href="aggregate.html#aggregate-functions-list"><span class="std std-ref">Aggregate functions list</span></a></li>
<li><a class="reference internal" href="ptable.html#ptable-functions-list"><span class="std std-ref">Table functions list</span></a></li>
</ul>
</div>
<p>Scalar functions</p>
<p>Programmable scalar functions work in a similar way as standard SQL scalar functions such as <em>abs()</em>, <em>lower()</em> and <em>upper()</em>.
Their implementation is done in Python, and they are able to use all Python facilities and libraries.</p>
<p>An example of an SQL statement using an external scalar function is:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">detectlang</span><span class="p">(</span><span class="s1">&#39;Il en est des livres comme du feu de nos foyers&#39;</span><span class="p">);</span>
<span class="n">french</span>
</pre></div>
</div>
<p>Above statement executes the <em>detectlang</em> function, which tries to detect the language of a snippet of text by analysing its statistical properties.
On the above example the snippet is a Voltaire quote, and the correct answer from <em>detectlang</em> is that it is in french.</p>
<p>If we wished to do the same for multiple quotes then we could use the following SQL statement (assuming the existence of a <em>quotes_table</em> which contains the column <em>quote</em>):</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">detectlang</span><span class="p">(</span><span class="n">quote</span><span class="p">)</span> <span class="k">from</span> <span class="n">quotes_table</span><span class="p">;</span>
<span class="n">french</span>
<span class="n">english</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="row.html#row-functions-list"><span class="std std-ref">Scalar functions list</span></a></li>
<li><a class="reference internal" href="row.html#functions.row.langtools.detectlang" title="functions.row.langtools.detectlang"><code class="xref py py-func docutils literal"><span class="pre">detectlang()</span></code></a></li>
</ul>
</div>

<p>Aggregate functions</p>
<p>Programmable aggregate functions work in a similar way as standard SQL aggregate functions such as <em>sum()</em>, <em>min()</em> and <em>max()</em>.
Their implementation is done in Python, and as is also the case for scalar functions, all Python facilities and libraries are available.</p>
<p>An example of an SQL statement using an external aggregate function is:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="ss">&quot;term1+term2&quot;</span> <span class="k">as</span> <span class="n">a</span> <span class="k">UNION</span> <span class="k">select</span> <span class="ss">&quot;term2 term3&quot;</span> <span class="k">as</span> <span class="n">a</span><span class="p">;</span>
<span class="n">term1</span><span class="o">+</span><span class="n">term2</span>
<span class="n">term2</span> <span class="n">term3</span>
<span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">concatterms</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">from</span> <span class="p">(</span><span class="k">select</span> <span class="ss">&quot;term1+term2&quot;</span> <span class="k">as</span> <span class="n">a</span> <span class="k">UNION</span> <span class="k">select</span> <span class="ss">&quot;term2 term3&quot;</span> <span class="k">as</span> <span class="n">a</span><span class="p">);</span>
<span class="n">term1</span><span class="o">+</span><span class="n">term2</span> <span class="n">term2</span> <span class="n">term3</span>
</pre></div>
</div>
<p>The statement above, executes the <a class="reference internal" href="aggregate.html#functions.aggregate.text.concatterms" title="functions.aggregate.text.concatterms"><code class="xref py py-func docutils literal"><span class="pre">concatterms()</span></code></a> function, which concatenates strings of terms together, while keeping the terms disjoint.</p>
<p>Using the aggregate function above, together with a scalar function is also possible.
To concatenate together only the input string keywords we could execute the following SQL:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">concatterms</span><span class="p">(</span><span class="n">keywords</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
         <span class="k">from</span> <span class="p">(</span><span class="k">select</span> <span class="ss">&quot;term1+term2&quot;</span> <span class="k">as</span> <span class="n">a</span> <span class="k">UNION</span> <span class="k">select</span> <span class="ss">&quot;term2 term3&quot;</span> <span class="k">as</span> <span class="n">a</span><span class="p">);</span>
<span class="n">term1</span> <span class="n">term2</span> <span class="n">term2</span> <span class="n">term3</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="aggregate.html#aggregate-functions-list"><span class="std std-ref">Aggregate functions list</span></a></li>
<li><a class="reference internal" href="aggregate.html#functions.aggregate.text.concatterms" title="functions.aggregate.text.concatterms"><code class="xref py py-func docutils literal"><span class="pre">concatterms()</span></code></a></li>
<li><a class="reference internal" href="row.html#functions.row.text.keywords" title="functions.aggregate.text.concatterms"><code class="xref py py-func docutils literal"><span class="pre">keywords()</span></code></li>
</ul>
</div>
</div>
</a>
<p>Polymorphic tables</p>
<p>Polymorphic tables are actually functions that take parameters and output table like data. They can be used in the SQL syntax wherever
a regular table would be placed.</p>
<p>Polymorphic tables are one of the most powerful function classes in YeSQL. They can function in a regular table fashion,
where the output data is finite in number. In case YeSQL is integrated with SQLite API, the output data can be in a streaming fashion, where the output stream can be infinite.</p>
<p>This, together with the SQL syntax extensions of YeSQL, creates a very powerful environment with which a variety
of standard YeSQL features have been developed, such as the <em>multisets</em>, <em>workflow engine</em>,
<em>direct data load from filesystem or network</em>, etc.</p>
<p>Typical examples of polymorphic tables sources are files, SQL query resultsets, or even external programs output.</p>
<p>Using polymorphic tables can be done in a variety of ways.
The first is <strong>parametric table</strong>:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">python</span> <span class="n">yesql</span><span class="p">.</span><span class="n">py</span>
<span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">file</span><span class="p">(</span><span class="s1">&#39;./demo/continents.tsv&#39;</span><span class="p">)</span> <span class="k">limit</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">Asia</span><span class="o">|</span><span class="n">AF</span>
<span class="n">Europe</span><span class="o">|</span><span class="n">AL</span>
</pre></div>
</div>
<p>What the example above does, is to read the tab separated “continents.tsv” filesystem file as a table.
Using the standard <em>limit</em> SQL directive, the output is limited to only 2 rows.</p>
<p>An example showing the streaming nature of YeSQL's polymorphic tables on top of SQLITE's API is:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">C1</span> <span class="k">from</span> <span class="n">pipe</span><span class="p">(</span><span class="s1">&#39;query:date&#39;</span><span class="p">);</span>
<span class="n">Fri</span> <span class="n">Feb</span> <span class="mi">1</span> <span class="mi">12</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span><span class="mi">55</span> <span class="n">EET</span> <span class="mi">2000</span>
<span class="ss">&quot;&quot;</span>
<span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">strsplit</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span><span class="s1">&#39;delimiter: &#39;</span><span class="p">)</span> <span class="k">from</span> <span class="n">pipe</span><span class="p">(</span><span class="s1">&#39;query:date&#39;</span><span class="p">);</span>
<span class="n">Mon</span><span class="o">|</span><span class="n">Feb</span><span class="o">||</span><span class="mi">1</span><span class="o">|</span><span class="mi">12</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span><span class="mi">56</span><span class="o">|</span><span class="n">EET</span><span class="o">|</span><span class="mi">2000</span>
</pre></div>
</div>
<p>The first of the above examples executes system’s “date” command through the use of the <a class="reference internal" href="ptable.html#module-functions.ptable.pipe" title="functions.ptable.pipe"><code class="xref py py-mod docutils literal"><span class="pre">pipe</span></code></a> polymorphic table.
Notice that the <a class="reference internal" href="ptable.html#module-functions.ptable.pipe" title="functions.ptable.pipe"><code class="xref py py-mod docutils literal"><span class="pre">pipe</span></code></a> polymorphic table has a default returned schema, having one column named <em>C1.</em></p>
<p>The second of the above examples does the same as the previous one, however it also splits <a class="reference internal" href="ptable.html#module-functions.ptable.pipe" title="functions.ptable.pipe"><code class="xref py py-mod docutils literal"><span class="pre">pipe</span></code></a>’s output,
using space as a delimiter, into multiple columns through <a class="reference internal" href="row.html#functions.row.formating.strsplit" title="functions.row.formating.strsplit"><code class="xref py py-func docutils literal"><span class="pre">strsplit()</span></code></a> scalar function.</p>
<p>At this point, we should skip a little ahead, and mention two peculiarities on the queries above.
The first one is the “query:date” parameter of <a class="reference internal" href="ptable.html#module-functions.ptable.pipe" title="functions.ptable.pipe"><code class="xref py py-mod docutils literal"><span class="pre">pipe</span></code></a>.
This in YeSQL is called a <em>named parameter</em>, where the part before the “:” is a parameter’s name and the second part is a parameter’s value.</p>
<p>The second peculiarity is the that the scalar function <a class="reference internal" href="row.html#functions.row.formating.strsplit" title="functions.row.formating.strsplit"><code class="xref py py-func docutils literal"><span class="pre">strsplit()</span></code></a> returns multiple columns.
This is a <a class="reference internal" href="#tutmultiset"><span class="std std-ref">multiset</span></a> function, able to return as many columns and rows as it wishes.
To see the column names and column types of second query above, we can execute:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">yesql</span><span class="o">&gt;</span> <span class="n">coltypes</span> <span class="k">select</span> <span class="n">strsplit</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span><span class="s1">&#39;delimiter: &#39;</span><span class="p">)</span> <span class="k">from</span> <span class="n">pipe</span><span class="p">(</span><span class="s1">&#39;query:date&#39;</span><span class="p">);</span>
<span class="n">C1</span><span class="o">|</span><span class="nb">text</span>
<span class="n">C2</span><span class="o">|</span><span class="nb">text</span>
<span class="n">C3</span><span class="o">|</span><span class="nb">text</span>
<span class="n">C4</span><span class="o">|</span><span class="nb">text</span>
<span class="n">C5</span><span class="o">|</span><span class="nb">text</span>
<span class="n">C6</span><span class="o">|</span><span class="nb">text</span>
<span class="n">C7</span><span class="o">|</span><span class="nb">text</span>
</pre></div>
</div>
<p>The “coltypes” in the above query may look like a special function of the terminal but in essence it is also
a polymorphic table that takes as input a query and returns a table having as first column the column names
of the inside query and as second column the column types of the inside query.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="ptable.html#module-functions.ptable.coltypes" title="functions.ptable.coltypes"><code class="xref py py-mod docutils literal"><span class="pre">coltypes</span></code></a> is able to be used in front of a query due to YeSQL's language extensions.
</li>
</ul>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="ptable.html#ptable-functions-list"><span class="std std-ref">Table functions list</span></a></li>
<li><a class="reference internal" href="ptable.html#module-functions.ptable.file" title="functions.ptable.file"><code class="xref py py-mod docutils literal"><span class="pre">file</span></code></a></li>
<li><a class="reference internal" href="ptable.html#module-functions.ptable.pipe" title="functions.ptable.pipe"><code class="xref py py-mod docutils literal"><span class="pre">pipe</span></code></a></li>
<li><a class="reference internal" href="row.html#functions.row.formating.strsplit" title="functions.row.formating.strsplit"><code class="xref py py-func docutils literal"><span class="pre">strsplit()</span></code></a></li>
<li><a class="reference internal" href="ptable.html#module-functions.ptable.coltypes" title="functions.ptable.coltypes"><code class="xref py py-mod docutils literal"><span class="pre">coltypes</span></code></a></li>
</ul>
</div>
</div>

<div class="section" id="multisets">
<span id="tutmultiset"></span><h2>Multisets<a class="headerlink" href="#multisets" title="Permalink to this headline">¶</a></h2>
<p>Early in the development of YeSQL, the need to return multiple rows and columns from scalar and aggregate functions, arose.
This need was satisfied through the use of <em>expand</em> polymorphic table.</p>
<p>Polymorphic table <em>expand</em> works by receiving in its input the results of a function that returns multiple rows and columns. 
It expands its input to multiple rows/columns and returns them as a table.
<p>To make multiset usage transparent to the user, YeSQL’ SQL preprocessor, inserts automatically
the <em>expand</em> polymorphic table whenever a multiset producing function is met.
</p>
<p>An example of a multiset scalar function which produces multiple columns is:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">strsplit</span><span class="p">(</span><span class="ss">&quot;one,two,three&quot;</span><span class="p">);</span>
<span class="n">one</span><span class="o">|</span><span class="n">two</span><span class="o">|</span><span class="n">three</span>
</pre></div>
</div>
<p>And one which produces multiple rows is:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">strsplitv</span><span class="p">(</span><span class="ss">&quot;one,two,three&quot;</span><span class="p">);</span>
<span class="n">one</span>
<span class="n">two</span>
<span class="n">three</span>
</pre></div>
</div>
<p>Both of the functions above, break their input on “comma” by default.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="row.html#functions.row.formating.strsplit" title="functions.row.formating.strsplit"><code class="xref py py-func docutils literal"><span class="pre">strsplit()</span></code></a></li>
<li><a class="reference internal" href="row.html#functions.row.formating.strsplitv" title="functions.row.formating.strsplitv"><code class="xref py py-func docutils literal"><span class="pre">strsplitv()</span></code></a></li>
</ul>
</div>
</div>
<div class="section" id="workflows">
<h2>Workflows<a class="headerlink" href="#workflows" title="Permalink to this headline">¶</a></h2>
<p>From the beginning YeSQL was designed for building complete data processing systems with it.
In YeSQL, workflows are viewed as a series of queries to be executed sequentially.</p>
<p>The main function that implements YeSQL’ workflow engine is <a class="reference internal" href="ptable.html#module-functions.ptable.exec" title="functions.ptable.exec"><code class="xref py py-mod docutils literal"><span class="pre">exec</span></code></a> polymorphic table:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">yesql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="s1">&#39;select 5&#39;</span><span class="p">;</span>
<span class="k">select</span> <span class="mi">5</span>
<span class="n">yesql</span><span class="o">&gt;</span> <span class="k">exec</span> <span class="k">select</span> <span class="s1">&#39;select 5&#39;</span><span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Polymorphic table <a class="reference internal" href="ptable.html#module-functions.ptable.exec" title="functions.ptable.exec"><code class="xref py py-mod docutils literal"><span class="pre">exec</span></code></a>, takes as input an SQL query, executes it and then operates on the <strong>results</strong> of the input query, executing them sequentially and returning “1” if all the queries executed successfully, or throwing an error if any queries failed to execute correctly.</p>
<p>This design enables <a class="reference internal" href="ptable.html#module-functions.ptable.exec" title="functions.ptable.exec"><code class="xref py py-mod docutils literal"><span class="pre">exec</span></code></a> to work in tandem with other polymorphic tables that feed to it the workflows to be executed.
The most frequent combination is:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">yesql</span><span class="o">&gt;</span> <span class="k">exec</span> <span class="n">flow</span> <span class="n">file</span> <span class="s1">&#39;workflow.sql&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>What the query above does, is to open and read the “workflow.sql” filesystem file via
the <em>file</em> polymorphic table, then feed its results into the <em>flow</em> polymorphic table
which collects in one line the “broken into multiple lines” queries, and finally
to feed the resulting queries to <a class="reference internal" href="ptable.html#module-functions.ptable.exec" title="functions.ptable.exec"><code class="xref py py-mod docutils literal"><span class="pre">exec</span></code></a> polymorphic table which will execute them.</p>
<p>The above combination of polymorphic tables presents, one the most powerful aspects of YeSQL.
Namely the ability to create complex functionality (in this instance a workflow engine), by quickly combining simple entities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Another benefit of using a relational database to implement a workflow engine, is that all ACID properties
of the database are still present during the workflow processing. </div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="ptable.html#module-functions.ptable.exec" title="functions.ptable.exec"><code class="xref py py-mod docutils literal"><span class="pre">exec</span></code></a></li>
<li><a class="reference internal" href="ptable.html#module-functions.ptable.flow" title="functions.ptable.flow"><code class="xref py py-mod docutils literal"><span class="pre">flow</span></code></a></li>
<li><a class="reference internal" href="ptable.html#module-functions.ptable.file" title="functions.ptable.file"><code class="xref py py-mod docutils literal"><span class="pre">file</span></code></a></li>
</ul>
</div>
</div>
<div class="section" id="designing-and-building-a-data-processing-system-with-YeSQL">
<h2>Designing and building a data processing system with YeSQL<a class="headerlink" href="#designing-and-building-a-data-processing-system-with-YeSQL" title="Permalink to this headline">¶</a></h2>
<p>Concerning the design of a data processing system.
The required steps that have to be made when <strong>designing</strong> a data processing system with YeSQL are:</p>
<ol class="arabic simple">
<li>Define the problem you are trying to solve</li>
<li>Break the problem into workflows</li>
<li>Break the workflows into queries</li>
<li>Find the functions that the queries will need</li>
<li>Find the Python libraries that the functions will need</li>
</ol>
<p>The steps above, are mostly self evident, and should be made in the order that they are presented.</p>
<p>To <strong>build</strong> the data processing system, the above steps have to be followed, finding/building the required entities (functions, queries), for each step, <strong>going from bottom to top</strong> (Step 5 to Step 2),</p>
<p>In practice we have found that there is always some overlap between the designing and building stages and between steps.
Great care should be given, when designing, on the most difficult and time consuming step, which is step 1. When step 1 is successfully executed, the speed with which the rest of the steps are designed and following that, building them from bottom to top, is extremely fast in our experience.</p>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            
  <h3><a href="index.html">YeSQL specifications</a></h3>
  <ul>
<li><a class="reference internal" href="#">Detailed specifications</a><ul>
<li><a class="reference internal" href="#functions">Functions</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#multisets">Multisets</a></li>
<li><a class="reference internal" href="#workflows">Workflows</a></li>
<li><a class="reference internal" href="#designing-and-building-a-data-processing-system-with-YeSQL">Designing and building a data processing system with YeSQL</a></li>
</ul>
</li>
</ul>

 
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    
  </body>
</html>